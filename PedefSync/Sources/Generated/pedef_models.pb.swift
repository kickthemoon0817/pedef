// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pedef_models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Annotation types matching Swift AnnotationType enum
public enum Pedef_AnnotationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case highlight // = 1
  case underline // = 2
  case strikethrough // = 3
  case textNote // = 4
  case stickyNote // = 5
  case freehandDrawing // = 6
  case shape // = 7
  case bookmark // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .highlight
    case 2: self = .underline
    case 3: self = .strikethrough
    case 4: self = .textNote
    case 5: self = .stickyNote
    case 6: self = .freehandDrawing
    case 7: self = .shape
    case 8: self = .bookmark
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .highlight: return 1
    case .underline: return 2
    case .strikethrough: return 3
    case .textNote: return 4
    case .stickyNote: return 5
    case .freehandDrawing: return 6
    case .shape: return 7
    case .bookmark: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pedef_AnnotationType] = [
    .unspecified,
    .highlight,
    .underline,
    .strikethrough,
    .textNote,
    .stickyNote,
    .freehandDrawing,
    .shape,
    .bookmark,
  ]

}

/// Collection types matching Swift CollectionType enum
public enum Pedef_CollectionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case folder // = 1
  case smartFolder // = 2
  case readingList // = 3
  case favorites // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .folder
    case 2: self = .smartFolder
    case 3: self = .readingList
    case 4: self = .favorites
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .folder: return 1
    case .smartFolder: return 2
    case .readingList: return 3
    case .favorites: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Pedef_CollectionType] = [
    .unspecified,
    .folder,
    .smartFolder,
    .readingList,
    .favorites,
  ]

}

/// Bounding rectangle for annotations
public struct Pedef_Rect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Double = 0

  public var y: Double = 0

  public var width: Double = 0

  public var height: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Paper metadata (excludes PDF binary data — transferred via PaperService streaming RPCs)
public struct Pedef_PaperMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var id: String {
    get {_storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var title: String {
    get {_storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var authors: [String] {
    get {_storage._authors}
    set {_uniqueStorage()._authors = newValue}
  }

  /// empty if unset
  public var abstract: String {
    get {_storage._abstract}
    set {_uniqueStorage()._abstract = newValue}
  }

  public var doi: String {
    get {_storage._doi}
    set {_uniqueStorage()._doi = newValue}
  }

  public var arxivID: String {
    get {_storage._arxivID}
    set {_uniqueStorage()._arxivID = newValue}
  }

  public var publishedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._publishedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._publishedDate = newValue}
  }
  /// Returns true if `publishedDate` has been explicitly set.
  public var hasPublishedDate: Bool {_storage._publishedDate != nil}
  /// Clears the value of `publishedDate`. Subsequent reads from it will return its default value.
  public mutating func clearPublishedDate() {_uniqueStorage()._publishedDate = nil}

  public var journal: String {
    get {_storage._journal}
    set {_uniqueStorage()._journal = newValue}
  }

  public var volume: String {
    get {_storage._volume}
    set {_uniqueStorage()._volume = newValue}
  }

  public var issue: String {
    get {_storage._issue}
    set {_uniqueStorage()._issue = newValue}
  }

  public var pages: String {
    get {_storage._pages}
    set {_uniqueStorage()._pages = newValue}
  }

  public var keywords: [String] {
    get {_storage._keywords}
    set {_uniqueStorage()._keywords = newValue}
  }

  public var pageCount: Int32 {
    get {_storage._pageCount}
    set {_uniqueStorage()._pageCount = newValue}
  }

  public var fileSize: Int64 {
    get {_storage._fileSize}
    set {_uniqueStorage()._fileSize = newValue}
  }

  public var thumbnailData: Data {
    get {_storage._thumbnailData}
    set {_uniqueStorage()._thumbnailData = newValue}
  }

  /// 0.0–1.0
  public var readingProgress: Double {
    get {_storage._readingProgress}
    set {_uniqueStorage()._readingProgress = newValue}
  }

  public var currentPage: Int32 {
    get {_storage._currentPage}
    set {_uniqueStorage()._currentPage = newValue}
  }

  public var lastOpenedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._lastOpenedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastOpenedDate = newValue}
  }
  /// Returns true if `lastOpenedDate` has been explicitly set.
  public var hasLastOpenedDate: Bool {_storage._lastOpenedDate != nil}
  /// Clears the value of `lastOpenedDate`. Subsequent reads from it will return its default value.
  public mutating func clearLastOpenedDate() {_uniqueStorage()._lastOpenedDate = nil}

  /// seconds
  public var totalReadingTime: Double {
    get {_storage._totalReadingTime}
    set {_uniqueStorage()._totalReadingTime = newValue}
  }

  public var importedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._importedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._importedDate = newValue}
  }
  /// Returns true if `importedDate` has been explicitly set.
  public var hasImportedDate: Bool {_storage._importedDate != nil}
  /// Clears the value of `importedDate`. Subsequent reads from it will return its default value.
  public mutating func clearImportedDate() {_uniqueStorage()._importedDate = nil}

  public var modifiedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._modifiedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedDate = newValue}
  }
  /// Returns true if `modifiedDate` has been explicitly set.
  public var hasModifiedDate: Bool {_storage._modifiedDate != nil}
  /// Clears the value of `modifiedDate`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedDate() {_uniqueStorage()._modifiedDate = nil}

  public var customMetadata: Dictionary<String,String> {
    get {_storage._customMetadata}
    set {_uniqueStorage()._customMetadata = newValue}
  }

  /// legacy string tags
  public var tags: [String] {
    get {_storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// Tag object UUIDs
  public var tagIds: [String] {
    get {_storage._tagIds}
    set {_uniqueStorage()._tagIds = newValue}
  }

  /// Collection UUIDs
  public var collectionIds: [String] {
    get {_storage._collectionIds}
    set {_uniqueStorage()._collectionIds = newValue}
  }

  /// soft delete flag
  public var isDeleted: Bool {
    get {_storage._isDeleted}
    set {_uniqueStorage()._isDeleted = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Annotation DTO
public struct Pedef_AnnotationDTO: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var id: String {
    get {_storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// parent Paper UUID
  public var paperID: String {
    get {_storage._paperID}
    set {_uniqueStorage()._paperID = newValue}
  }

  public var type: Pedef_AnnotationType {
    get {_storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var colorHex: String {
    get {_storage._colorHex}
    set {_uniqueStorage()._colorHex = newValue}
  }

  public var pageIndex: Int32 {
    get {_storage._pageIndex}
    set {_uniqueStorage()._pageIndex = newValue}
  }

  public var bounds: Pedef_Rect {
    get {_storage._bounds ?? Pedef_Rect()}
    set {_uniqueStorage()._bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  public var hasBounds: Bool {_storage._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  public mutating func clearBounds() {_uniqueStorage()._bounds = nil}

  public var selectedText: String {
    get {_storage._selectedText}
    set {_uniqueStorage()._selectedText = newValue}
  }

  public var noteContent: String {
    get {_storage._noteContent}
    set {_uniqueStorage()._noteContent = newValue}
  }

  public var drawingData: Data {
    get {_storage._drawingData}
    set {_uniqueStorage()._drawingData = newValue}
  }

  public var tags: [String] {
    get {_storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var createdDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._createdDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdDate = newValue}
  }
  /// Returns true if `createdDate` has been explicitly set.
  public var hasCreatedDate: Bool {_storage._createdDate != nil}
  /// Clears the value of `createdDate`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedDate() {_uniqueStorage()._createdDate = nil}

  public var modifiedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._modifiedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._modifiedDate = newValue}
  }
  /// Returns true if `modifiedDate` has been explicitly set.
  public var hasModifiedDate: Bool {_storage._modifiedDate != nil}
  /// Clears the value of `modifiedDate`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedDate() {_uniqueStorage()._modifiedDate = nil}

  public var isDeleted: Bool {
    get {_storage._isDeleted}
    set {_uniqueStorage()._isDeleted = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Collection DTO
public struct Pedef_CollectionDTO: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var id: String = String()

  public var name: String = String()

  public var type: Pedef_CollectionType = .unspecified

  public var colorHex: String = String()

  public var iconName: String = String()

  /// parent Collection UUID (empty if root)
  public var parentID: String = String()

  public var paperIds: [String] = []

  /// JSON-encoded smart folder rules
  public var smartRulesData: Data = Data()

  public var notes: String = String()

  public var sortOrder: Int32 = 0

  public var createdDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdDate = newValue}
  }
  /// Returns true if `createdDate` has been explicitly set.
  public var hasCreatedDate: Bool {self._createdDate != nil}
  /// Clears the value of `createdDate`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedDate() {self._createdDate = nil}

  public var modifiedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_modifiedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modifiedDate = newValue}
  }
  /// Returns true if `modifiedDate` has been explicitly set.
  public var hasModifiedDate: Bool {self._modifiedDate != nil}
  /// Clears the value of `modifiedDate`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedDate() {self._modifiedDate = nil}

  public var isDeleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modifiedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Tag DTO
public struct Pedef_TagDTO: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var id: String = String()

  public var name: String = String()

  public var colorHex: String = String()

  public var usageCount: Int32 = 0

  public var createdDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_createdDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdDate = newValue}
  }
  /// Returns true if `createdDate` has been explicitly set.
  public var hasCreatedDate: Bool {self._createdDate != nil}
  /// Clears the value of `createdDate`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedDate() {self._createdDate = nil}

  /// Papers using this tag
  public var paperIds: [String] = []

  public var isDeleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Tracks which entities were deleted (for delta sync)
public struct Pedef_Deletions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paperIds: [String] = []

  public var annotationIds: [String] = []

  public var collectionIds: [String] = []

  public var tagIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pedef"

extension Pedef_AnnotationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ANNOTATION_TYPE_UNSPECIFIED\0\u{1}ANNOTATION_TYPE_HIGHLIGHT\0\u{1}ANNOTATION_TYPE_UNDERLINE\0\u{1}ANNOTATION_TYPE_STRIKETHROUGH\0\u{1}ANNOTATION_TYPE_TEXT_NOTE\0\u{1}ANNOTATION_TYPE_STICKY_NOTE\0\u{1}ANNOTATION_TYPE_FREEHAND_DRAWING\0\u{1}ANNOTATION_TYPE_SHAPE\0\u{1}ANNOTATION_TYPE_BOOKMARK\0")
}

extension Pedef_CollectionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0COLLECTION_TYPE_UNSPECIFIED\0\u{1}COLLECTION_TYPE_FOLDER\0\u{1}COLLECTION_TYPE_SMART_FOLDER\0\u{1}COLLECTION_TYPE_READING_LIST\0\u{1}COLLECTION_TYPE_FAVORITES\0")
}

extension Pedef_Rect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rect"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    if self.width.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 3)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_Rect, rhs: Pedef_Rect) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_PaperMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaperMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}authors\0\u{1}abstract\0\u{1}doi\0\u{3}arxiv_id\0\u{3}published_date\0\u{1}journal\0\u{1}volume\0\u{1}issue\0\u{1}pages\0\u{1}keywords\0\u{3}page_count\0\u{3}file_size\0\u{3}thumbnail_data\0\u{3}reading_progress\0\u{3}current_page\0\u{3}last_opened_date\0\u{3}total_reading_time\0\u{3}imported_date\0\u{3}modified_date\0\u{3}custom_metadata\0\u{1}tags\0\u{3}tag_ids\0\u{3}collection_ids\0\u{3}is_deleted\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _title: String = String()
    var _authors: [String] = []
    var _abstract: String = String()
    var _doi: String = String()
    var _arxivID: String = String()
    var _publishedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _journal: String = String()
    var _volume: String = String()
    var _issue: String = String()
    var _pages: String = String()
    var _keywords: [String] = []
    var _pageCount: Int32 = 0
    var _fileSize: Int64 = 0
    var _thumbnailData: Data = Data()
    var _readingProgress: Double = 0
    var _currentPage: Int32 = 0
    var _lastOpenedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _totalReadingTime: Double = 0
    var _importedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _customMetadata: Dictionary<String,String> = [:]
    var _tags: [String] = []
    var _tagIds: [String] = []
    var _collectionIds: [String] = []
    var _isDeleted: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _authors = source._authors
      _abstract = source._abstract
      _doi = source._doi
      _arxivID = source._arxivID
      _publishedDate = source._publishedDate
      _journal = source._journal
      _volume = source._volume
      _issue = source._issue
      _pages = source._pages
      _keywords = source._keywords
      _pageCount = source._pageCount
      _fileSize = source._fileSize
      _thumbnailData = source._thumbnailData
      _readingProgress = source._readingProgress
      _currentPage = source._currentPage
      _lastOpenedDate = source._lastOpenedDate
      _totalReadingTime = source._totalReadingTime
      _importedDate = source._importedDate
      _modifiedDate = source._modifiedDate
      _customMetadata = source._customMetadata
      _tags = source._tags
      _tagIds = source._tagIds
      _collectionIds = source._collectionIds
      _isDeleted = source._isDeleted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._authors) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._abstract) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._doi) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._arxivID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._publishedDate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._journal) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._volume) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._issue) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._pages) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._keywords) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._pageCount) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._fileSize) }()
        case 15: try { try decoder.decodeSingularBytesField(value: &_storage._thumbnailData) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._readingProgress) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._currentPage) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._lastOpenedDate) }()
        case 19: try { try decoder.decodeSingularDoubleField(value: &_storage._totalReadingTime) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._importedDate) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedDate) }()
        case 22: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._customMetadata) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 24: try { try decoder.decodeRepeatedStringField(value: &_storage._tagIds) }()
        case 25: try { try decoder.decodeRepeatedStringField(value: &_storage._collectionIds) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._isDeleted) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._authors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._authors, fieldNumber: 3)
      }
      if !_storage._abstract.isEmpty {
        try visitor.visitSingularStringField(value: _storage._abstract, fieldNumber: 4)
      }
      if !_storage._doi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._doi, fieldNumber: 5)
      }
      if !_storage._arxivID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._arxivID, fieldNumber: 6)
      }
      try { if let v = _storage._publishedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._journal.isEmpty {
        try visitor.visitSingularStringField(value: _storage._journal, fieldNumber: 8)
      }
      if !_storage._volume.isEmpty {
        try visitor.visitSingularStringField(value: _storage._volume, fieldNumber: 9)
      }
      if !_storage._issue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issue, fieldNumber: 10)
      }
      if !_storage._pages.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pages, fieldNumber: 11)
      }
      if !_storage._keywords.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keywords, fieldNumber: 12)
      }
      if _storage._pageCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pageCount, fieldNumber: 13)
      }
      if _storage._fileSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fileSize, fieldNumber: 14)
      }
      if !_storage._thumbnailData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._thumbnailData, fieldNumber: 15)
      }
      if _storage._readingProgress.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._readingProgress, fieldNumber: 16)
      }
      if _storage._currentPage != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentPage, fieldNumber: 17)
      }
      try { if let v = _storage._lastOpenedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._totalReadingTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._totalReadingTime, fieldNumber: 19)
      }
      try { if let v = _storage._importedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._modifiedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._customMetadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._customMetadata, fieldNumber: 22)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 23)
      }
      if !_storage._tagIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tagIds, fieldNumber: 24)
      }
      if !_storage._collectionIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._collectionIds, fieldNumber: 25)
      }
      if _storage._isDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._isDeleted, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_PaperMetadata, rhs: Pedef_PaperMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._authors != rhs_storage._authors {return false}
        if _storage._abstract != rhs_storage._abstract {return false}
        if _storage._doi != rhs_storage._doi {return false}
        if _storage._arxivID != rhs_storage._arxivID {return false}
        if _storage._publishedDate != rhs_storage._publishedDate {return false}
        if _storage._journal != rhs_storage._journal {return false}
        if _storage._volume != rhs_storage._volume {return false}
        if _storage._issue != rhs_storage._issue {return false}
        if _storage._pages != rhs_storage._pages {return false}
        if _storage._keywords != rhs_storage._keywords {return false}
        if _storage._pageCount != rhs_storage._pageCount {return false}
        if _storage._fileSize != rhs_storage._fileSize {return false}
        if _storage._thumbnailData != rhs_storage._thumbnailData {return false}
        if _storage._readingProgress != rhs_storage._readingProgress {return false}
        if _storage._currentPage != rhs_storage._currentPage {return false}
        if _storage._lastOpenedDate != rhs_storage._lastOpenedDate {return false}
        if _storage._totalReadingTime != rhs_storage._totalReadingTime {return false}
        if _storage._importedDate != rhs_storage._importedDate {return false}
        if _storage._modifiedDate != rhs_storage._modifiedDate {return false}
        if _storage._customMetadata != rhs_storage._customMetadata {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._tagIds != rhs_storage._tagIds {return false}
        if _storage._collectionIds != rhs_storage._collectionIds {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_AnnotationDTO: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationDTO"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}paper_id\0\u{1}type\0\u{3}color_hex\0\u{3}page_index\0\u{1}bounds\0\u{3}selected_text\0\u{3}note_content\0\u{3}drawing_data\0\u{1}tags\0\u{3}created_date\0\u{3}modified_date\0\u{3}is_deleted\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _paperID: String = String()
    var _type: Pedef_AnnotationType = .unspecified
    var _colorHex: String = String()
    var _pageIndex: Int32 = 0
    var _bounds: Pedef_Rect? = nil
    var _selectedText: String = String()
    var _noteContent: String = String()
    var _drawingData: Data = Data()
    var _tags: [String] = []
    var _createdDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _modifiedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isDeleted: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _paperID = source._paperID
      _type = source._type
      _colorHex = source._colorHex
      _pageIndex = source._pageIndex
      _bounds = source._bounds
      _selectedText = source._selectedText
      _noteContent = source._noteContent
      _drawingData = source._drawingData
      _tags = source._tags
      _createdDate = source._createdDate
      _modifiedDate = source._modifiedDate
      _isDeleted = source._isDeleted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._paperID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._colorHex) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._pageIndex) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._bounds) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._selectedText) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._noteContent) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._drawingData) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createdDate) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._modifiedDate) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isDeleted) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._paperID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paperID, fieldNumber: 2)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if !_storage._colorHex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._colorHex, fieldNumber: 4)
      }
      if _storage._pageIndex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pageIndex, fieldNumber: 5)
      }
      try { if let v = _storage._bounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._selectedText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._selectedText, fieldNumber: 7)
      }
      if !_storage._noteContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._noteContent, fieldNumber: 8)
      }
      if !_storage._drawingData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._drawingData, fieldNumber: 9)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 10)
      }
      try { if let v = _storage._createdDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._modifiedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._isDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._isDeleted, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_AnnotationDTO, rhs: Pedef_AnnotationDTO) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._paperID != rhs_storage._paperID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._colorHex != rhs_storage._colorHex {return false}
        if _storage._pageIndex != rhs_storage._pageIndex {return false}
        if _storage._bounds != rhs_storage._bounds {return false}
        if _storage._selectedText != rhs_storage._selectedText {return false}
        if _storage._noteContent != rhs_storage._noteContent {return false}
        if _storage._drawingData != rhs_storage._drawingData {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._createdDate != rhs_storage._createdDate {return false}
        if _storage._modifiedDate != rhs_storage._modifiedDate {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_CollectionDTO: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionDTO"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}type\0\u{3}color_hex\0\u{3}icon_name\0\u{3}parent_id\0\u{3}paper_ids\0\u{3}smart_rules_data\0\u{1}notes\0\u{3}sort_order\0\u{3}created_date\0\u{3}modified_date\0\u{3}is_deleted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.colorHex) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.iconName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.parentID) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.paperIds) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.smartRulesData) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.sortOrder) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._createdDate) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._modifiedDate) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.isDeleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.colorHex.isEmpty {
      try visitor.visitSingularStringField(value: self.colorHex, fieldNumber: 4)
    }
    if !self.iconName.isEmpty {
      try visitor.visitSingularStringField(value: self.iconName, fieldNumber: 5)
    }
    if !self.parentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentID, fieldNumber: 6)
    }
    if !self.paperIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paperIds, fieldNumber: 7)
    }
    if !self.smartRulesData.isEmpty {
      try visitor.visitSingularBytesField(value: self.smartRulesData, fieldNumber: 8)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 9)
    }
    if self.sortOrder != 0 {
      try visitor.visitSingularInt32Field(value: self.sortOrder, fieldNumber: 10)
    }
    try { if let v = self._createdDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._modifiedDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if self.isDeleted != false {
      try visitor.visitSingularBoolField(value: self.isDeleted, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_CollectionDTO, rhs: Pedef_CollectionDTO) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.colorHex != rhs.colorHex {return false}
    if lhs.iconName != rhs.iconName {return false}
    if lhs.parentID != rhs.parentID {return false}
    if lhs.paperIds != rhs.paperIds {return false}
    if lhs.smartRulesData != rhs.smartRulesData {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.sortOrder != rhs.sortOrder {return false}
    if lhs._createdDate != rhs._createdDate {return false}
    if lhs._modifiedDate != rhs._modifiedDate {return false}
    if lhs.isDeleted != rhs.isDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_TagDTO: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagDTO"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{3}color_hex\0\u{3}usage_count\0\u{3}created_date\0\u{3}paper_ids\0\u{3}is_deleted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.colorHex) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.usageCount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdDate) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.paperIds) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isDeleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.colorHex.isEmpty {
      try visitor.visitSingularStringField(value: self.colorHex, fieldNumber: 3)
    }
    if self.usageCount != 0 {
      try visitor.visitSingularInt32Field(value: self.usageCount, fieldNumber: 4)
    }
    try { if let v = self._createdDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.paperIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paperIds, fieldNumber: 6)
    }
    if self.isDeleted != false {
      try visitor.visitSingularBoolField(value: self.isDeleted, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_TagDTO, rhs: Pedef_TagDTO) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.colorHex != rhs.colorHex {return false}
    if lhs.usageCount != rhs.usageCount {return false}
    if lhs._createdDate != rhs._createdDate {return false}
    if lhs.paperIds != rhs.paperIds {return false}
    if lhs.isDeleted != rhs.isDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_Deletions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Deletions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}paper_ids\0\u{3}annotation_ids\0\u{3}collection_ids\0\u{3}tag_ids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.paperIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.annotationIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.tagIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paperIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paperIds, fieldNumber: 1)
    }
    if !self.annotationIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.annotationIds, fieldNumber: 2)
    }
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 3)
    }
    if !self.tagIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_Deletions, rhs: Pedef_Deletions) -> Bool {
    if lhs.paperIds != rhs.paperIds {return false}
    if lhs.annotationIds != rhs.annotationIds {return false}
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.tagIds != rhs.tagIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
