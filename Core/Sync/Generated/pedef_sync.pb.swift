// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pedef_sync.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Pedef_PullRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fetch entities modified after this timestamp.
  /// If unset, returns all entities (full sync).
  public var since: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_since ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  public var hasSince: Bool {self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  public mutating func clearSince() {self._since = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _since: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pedef_PullResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var papers: [Pedef_PaperMetadata] = []

  public var annotations: [Pedef_AnnotationDTO] = []

  public var collections: [Pedef_CollectionDTO] = []

  public var tags: [Pedef_TagDTO] = []

  public var deletions: Pedef_Deletions {
    get {_deletions ?? Pedef_Deletions()}
    set {_deletions = newValue}
  }
  /// Returns true if `deletions` has been explicitly set.
  public var hasDeletions: Bool {self._deletions != nil}
  /// Clears the value of `deletions`. Subsequent reads from it will return its default value.
  public mutating func clearDeletions() {self._deletions = nil}

  /// Server time when this response was generated.
  /// Client should store this and use it as `since` in the next pull.
  public var serverTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_serverTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  public var hasServerTimestamp: Bool {self._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearServerTimestamp() {self._serverTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deletions: Pedef_Deletions? = nil
  fileprivate var _serverTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pedef_PushRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var papers: [Pedef_PaperMetadata] = []

  public var annotations: [Pedef_AnnotationDTO] = []

  public var collections: [Pedef_CollectionDTO] = []

  public var tags: [Pedef_TagDTO] = []

  public var deletions: Pedef_Deletions {
    get {_deletions ?? Pedef_Deletions()}
    set {_deletions = newValue}
  }
  /// Returns true if `deletions` has been explicitly set.
  public var hasDeletions: Bool {self._deletions != nil}
  /// Clears the value of `deletions`. Subsequent reads from it will return its default value.
  public mutating func clearDeletions() {self._deletions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deletions: Pedef_Deletions? = nil
}

/// Conflict detail for push responses
public struct Pedef_ConflictDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "paper", "annotation", "collection", "tag"
  public var entityType: String = String()

  /// UUID
  public var entityID: String = String()

  /// "server_wins" or "client_wins"
  public var resolution: String = String()

  /// human-readable reason
  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pedef_PushResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var conflicts: [Pedef_ConflictDetail] = []

  /// Server time when the push was processed.
  public var serverTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_serverTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  public var hasServerTimestamp: Bool {self._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearServerTimestamp() {self._serverTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serverTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Pedef_StatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pedef_StatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverVersion: String = String()

  public var paperCount: Int64 = 0

  public var annotationCount: Int64 = 0

  public var collectionCount: Int64 = 0

  public var tagCount: Int64 = 0

  public var lastModified: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_lastModified ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModified = newValue}
  }
  /// Returns true if `lastModified` has been explicitly set.
  public var hasLastModified: Bool {self._lastModified != nil}
  /// Clears the value of `lastModified`. Subsequent reads from it will return its default value.
  public mutating func clearLastModified() {self._lastModified = nil}

  /// total PDF storage
  public var storageBytesUsed: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastModified: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pedef"

extension Pedef_PullRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PullRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}since\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_PullRequest, rhs: Pedef_PullRequest) -> Bool {
    if lhs._since != rhs._since {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_PullResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PullResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}papers\0\u{1}annotations\0\u{1}collections\0\u{1}tags\0\u{1}deletions\0\u{3}server_timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.papers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.collections) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deletions) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._serverTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.papers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.papers, fieldNumber: 1)
    }
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 2)
    }
    if !self.collections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collections, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 4)
    }
    try { if let v = self._deletions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_PullResponse, rhs: Pedef_PullResponse) -> Bool {
    if lhs.papers != rhs.papers {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.collections != rhs.collections {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._deletions != rhs._deletions {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_PushRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}papers\0\u{1}annotations\0\u{1}collections\0\u{1}tags\0\u{1}deletions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.papers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.collections) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deletions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.papers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.papers, fieldNumber: 1)
    }
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 2)
    }
    if !self.collections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collections, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 4)
    }
    try { if let v = self._deletions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_PushRequest, rhs: Pedef_PushRequest) -> Bool {
    if lhs.papers != rhs.papers {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.collections != rhs.collections {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._deletions != rhs._deletions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_ConflictDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConflictDetail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}entity_type\0\u{3}entity_id\0\u{1}resolution\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resolution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityType.isEmpty {
      try visitor.visitSingularStringField(value: self.entityType, fieldNumber: 1)
    }
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 2)
    }
    if !self.resolution.isEmpty {
      try visitor.visitSingularStringField(value: self.resolution, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_ConflictDetail, rhs: Pedef_ConflictDetail) -> Bool {
    if lhs.entityType != rhs.entityType {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.resolution != rhs.resolution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_PushResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}conflicts\0\u{3}server_timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conflicts) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serverTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.conflicts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conflicts, fieldNumber: 2)
    }
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_PushResponse, rhs: Pedef_PushResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.conflicts != rhs.conflicts {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_StatusRequest, rhs: Pedef_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pedef_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_version\0\u{3}paper_count\0\u{3}annotation_count\0\u{3}collection_count\0\u{3}tag_count\0\u{3}last_modified\0\u{3}storage_bytes_used\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.paperCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.annotationCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.collectionCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.tagCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._lastModified) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.storageBytesUsed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 1)
    }
    if self.paperCount != 0 {
      try visitor.visitSingularInt64Field(value: self.paperCount, fieldNumber: 2)
    }
    if self.annotationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.annotationCount, fieldNumber: 3)
    }
    if self.collectionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.collectionCount, fieldNumber: 4)
    }
    if self.tagCount != 0 {
      try visitor.visitSingularInt64Field(value: self.tagCount, fieldNumber: 5)
    }
    try { if let v = self._lastModified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.storageBytesUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.storageBytesUsed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pedef_StatusResponse, rhs: Pedef_StatusResponse) -> Bool {
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.paperCount != rhs.paperCount {return false}
    if lhs.annotationCount != rhs.annotationCount {return false}
    if lhs.collectionCount != rhs.collectionCount {return false}
    if lhs.tagCount != rhs.tagCount {return false}
    if lhs._lastModified != rhs._lastModified {return false}
    if lhs.storageBytesUsed != rhs.storageBytesUsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
